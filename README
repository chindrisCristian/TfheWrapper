Detaliile se afla in documentatia oficiala.

Prin crearea acestei librării am încercat să demonstrez care ar putea fi gradul de optimizare adus aplicațiilor homomorfice prin utilizarea mai multor fire de execuție și rularea în paralel a operațiilor care permit această posibilitate. Dat fiind faptul că aplicația reprezintă o demonstrație, numărul de algoritmi dezvoltați este redus, încercând să punctez diferențele de viteză care pot fi obținute pe anumite operații. Aceste operații sunt criptarea, decriptarea, adunarea și înmulțirea.
Cu toate că pe piață există deja implementări pentru diferite librării pentru folosirea FHE-ului, proiectul curent își propune o nouă abordare asupra acestei tematici în care să se identifice cele mai rapide modalități de a efectua operații homomorfice și care să fie asamblate într-o colecție de clase care să ofere o anumită lejeritate în folosirea acestora.
Cazurile principale de utilizare ale bibliotecii se concentrează în jurul capabilităților de generare de chei, de criptare, de decriptare și de evaluare a operațiilor homomorfice.

Componenta KeyManager reprezintă suita de clase care se ocupă de crearea, organizarea și menținerea integrității cheilor folosite în cadrul aplicațiilor ce pot fi dezvoltate ulterior. Aceasta are ca scop generarea de chei, atât secrete cât și publice, salvarea lor în fișiere, citirea lor din fișiere cât și menținerea întregului ciclu de viață al celor din memorie. Modulul Encryptor poate să cripteze, sau să decripteze datele care îi sunt solicitate. Acesta poate lucra cu diferite tipuri de date, în funcție de necesitățile aplicațiilor pentru care va fi folosit ulterior. Din schema de mai sus reiese dependința față de componenta KeyManager. Această dependință rezultă din necesitatea de a folosi cheia secretă atât la criptare, cât și la decriptare. Componenta Evaluator are rolul de a efectua operații homomorfice pe elementele criptate. Această suită de clase poate executa diferite tipuri de operații. Se observă din schemă că depinde de componentele KeyManager și Cipher: pentru a putea efectua operațiile homomorfice avem nevoie de cheia publică și datele criptate pe care să executăm acele operații. Modulul Cipher reprezintă suita de clase care se ocupă efectiv de datele criptate. Modul de salvare în memorie este special conceput pentru a putea folosi arhitecturi paralele de calcul.
Paralelizarea operațiilor este realizată cu ajutorul bibliotecii Boost [57]. Voi menționa în continuare modalitatea de paralelizare pentru înmulțirea a două numere, deoarece aceasta a reprezentat una din părțile mai dificile pentru a fi implementate. Algoritmul este asemănător celui propus în [58], cu modificări asupra modului în care este realizată paralelizarea pe CPU. Codul pentru operațiile de adunare și înmulțire sunt afișate în Anexa 4. Fie 𝑎 și 𝑏 2 numere întregi reprezentate binar pe 𝑛=2𝑘 biți, 𝑘≥3. 
Din ecuația ( 42 ) rezultatele operațiilor ∧ vor fi reprezentate pe numere de biți diferite. Operația din dreapta egalului din ecuația ( 41 ) este realizată prin adunări succesive, realizate paralel pe un număr de fire de execuție egal cu 𝑛2, astfel: pentru fiecare fir de execuție se generează 𝑃𝑖 și 𝑃𝑛−1−𝑖, cu 0≤𝑖<𝑛2 (i reprezintă firul de execuție curent), ulterior se calculează sumele succesive dintre 𝑃𝑖 și 𝑃𝑛𝑠 −𝑖−1 după formula din ( 43 ), unde 1≤𝑠<𝑛, iar la fiecare pas 𝑠=𝑠⋅2. Indicele superior, 𝑗, reprezintă poziția primului bit pentru care se va efectua suma, având o operație pe 𝑛(𝑠−1)𝑠+𝑖+1 biți. Pentru fiecare fir de execuție se așteaptă terminarea operației de adunare curente înainte de începerea operației următoare, acestea fiind sincronizate folosind bariere.
